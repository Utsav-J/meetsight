Cross-platform audio I/O for Python, with PortAudio
PyAudio provides Python bindings for PortAudio, the cross platform audio API.

8 min. readView original
Snakey: Headphones wearing Python

PyAudio is distributed under the MIT License.

This library was originally inspired by:

pyPortAudio/fastaudio: Python bindings for PortAudio v18 API.
tkSnack: cross-platform sound toolkit for Tcl/Tk and Python.

What's new
November 23, 2024
PyAudio 0.2.14 pre-compiled wheels for Microsoft Windows (32-bit and 64-bit) are now available for Python 3.13 on PyPI. Install using pip, as described below.

November 6, 2023
PyAudio 0.2.14 is a new release that fixes a build issue. Thanks to Bhanu Victor DiCara for the help.

Also, PyAudio 0.2.14 pre-compiled wheels for Microsoft Windows (32-bit and 64-bit) are now available for Python 3.12 on PyPI. Install using pip, as described below.

December 26, 2022
PyAudio 0.2.13 is a new release focused on refactoring, maintenance, and cleanup. See the CHANGELOG in the source distribution for details. Notable changes include:

Fixed installation on Apple silicon. Thanks to Michael Parque for help with updating and testing!
pyaudio.Stream is now pyaudio.PyAudio.Stream, which should not affect existing code, as directly accessing the module-level pyaudio.Stream class has always been unsupported. Use PyAudio.open instead.
PaMacCoreStreamInfo.get_channel_map() and PaMacCoreStreamInfo.get_flags() methods are deprecated. Use the channel_map and flags properties, respectively, instead.
October 25, 2022
PyAudio 0.2.12 pre-compiled wheels for Microsoft Windows (32-bit and 64-bit) are now available for Python 3.11 on PyPI. Install using pip, as described below.

July 18, 2022
PyAudio 0.2.12 is a new release with many updates. See the CHANGELOG in the source distribution for details. Notably, the PyAudio build process for Microsoft Windows is streamlined, using the native toolchain. Special thanks to:

Sean Zimmermann for help with modernizing the Microsoft Windows build process
Jason Hihn for suggesting the use paFramesPerBufferUnspecified as the default frames per buffer
Eiichi Takamori for the patch that uses the system's preferred encoding
Matěj Cepl for the patches that skip unit tests that require audio hardware
Vasily Zakharov for fixes and suggestions to the documentation
Artur Janowiec for fixes to the website documentation
March 18, 2017
PyAudio 0.2.11 is a new release with a bug fix related to memory management.

Many thanks to both Blaise Potard and Matthias Schaff for discovering the issue and for their patches! Thanks as well to Timothy Port for helping to correct a docstring.

January 16, 2017
PyAudio 0.2.10 is a new release with bug fixes related to the Python GIL. It also introduces a few automated unit tests.

Great thanks to Michael Graczyk for discovering the GIL-related issues and for submitting a patch!

October 19, 2015
PyAudio installation is better streamlined. Install PyAudio on most platforms using pip.

October 18, 2015
PyAudio 0.2.9 is a new release with bug fixes related to overflow error handling and IOError exception arguments.

Many thanks to Tony Jacobson for discovering and helping with the overflow error. Thanks also to Sami Liedes for reporting the IOError exception issue!

April 12, 2014
PyAudio 0.2.8 is a new release with bug fixes related to the Python GIL and device name encoding.

Many thanks to Jason Roehm for discovering and patching the threading-related issue!

January 30, 2014
Many thanks to Sebastian Audet, who wrote instructions for building PyAudio using Microsoft Visual Studio!

October 27, 2012
PyAudio 0.2.7 is a new release with:

Modernized documentation format
Fix for callback (non-blocking) operation
Binaries for Python 3.3
Thanks again to Bastian Bechtold for his help converting the documentation for use with Sphinx! In addition, thanks to John K. Luebs for the callback fix.

October 14, 2012
PyAudio 0.2.6 is a new release with:

Python 3 support
Callback (non-blocking) operation
Bug fixes
Many thanks to Bastian Bechtold and Bob Jamison for their contributions! Without their patches and Bastian's careful review, this release would still be far away. Also, great thanks to Danilo J. S. Bellini for reporting bugs.

Note: As of this update, PyAudio is compatible with Python 2.6, Python 2.7, and Python 3.2. For Python installations older than 2.6, use PyAudio 0.2.4.

August 22, 2012
This web page has been translated to French—thanks to the efforts of Cyril Danilevski!

April 20, 2012
This web page has been translated to Russian—thanks to the efforts of Oleg Meister!

March 7, 2012
This web page has been translated to German—thanks to the efforts of Olga Babenko!

December 7, 2010
This web page has been translated to Belorussian—thanks to the efforts of Jason Fragoso!

November 2, 2010
PyAudio 0.2.4 has been uploaded to Debian (sid). A huge thanks to Felipe Sateler for sponsoring the package!

October 12, 2010
PyAudio 0.2.4 is a maintenance release—there are no new features or bug fixes. The binary packages now include PortAudio-v19 (r1535). The source for PyAudio is now in git (previously subversion).

November 2, 2008
PyAudio 0.2.3 fixes several outstanding bugs (thanks to all who have sent patches); see the CHANGELOG for details. PyAudio 0.2.3 provides bindings for PortAudio-v19 (r1395) and now includes binary distributions for Python 2.4, 2.5, and 2.6.

March 5, 2008
PyAudio 0.2.0 now works with both Python 2.4 and Python 2.5. Additionally, PyAudio features support for PortAudio's Mac OS X Host API Specific Stream Info extensions (e.g., for channel mapping)—see examples below. The new binary installers include an updated version of PortAudio-v19 (r1368).

July 6, 2006
PyAudio 0.1.0 is released.

Older news...


Installation
The current version is PyAudio v0.2.14 and supports Python version 3.8+. Install PyAudio using pip on most platforms. For PyAudio versions prior to v0.2.9, PyAudio distributed installation binaries, which are archived here.


Microsoft Windows

Install using pip:

python -m pip install pyaudio
Notes:

If pip is not already bundled with your installation of Python, get it here.
pip will fetch and install PyAudio wheels (prepackaged binaries). Currently, there are wheels compatible with the official distributions for Python 3.8, 3.9, 3.10, 3.11, and 3.12. Both 32-bit and 64-bit wheels are available.
These binaries include PortAudio v19 19.7.0, built using the native compiler toolchain. They support the Windows MME API, DirectSound, WASAPI, and WDM-KS. They do not include support for ASIO. If you require support for APIs not included, you will need to compile PortAudio and PyAudio.

Apple macOS

Use Homebrew to install the prerequisite portaudio library, then install PyAudio using pip:


            brew install portaudio
            

            pip install pyaudio
            
Notes:

If not already installed, download Homebrew.
pip will download the PyAudio source and build it for your version of Python.
Homebrew and building PyAudio also require installing the Command Line Tools for Xcode (more information).

GNU/Linux

Use the package manager to install PyAudio. For example, on Debian-based systems:


            sudo apt-get install python3-pyaudio
          
If the latest version of PyAudio is not available, install it using pip:


            pip install pyaudio
          
Notes:

pip will download the PyAudio source and build it for your system. Be sure to install the portaudio library development package (e.g., portaudio19-dev) and the python development package (e.g., python3-all-dev) beforehand.
For better isolation from system packages, consider installing PyAudio in a virtualenv.

PyAudio Source

Source is available for download at the Python Package Index (PyPI).

Or clone the git repository:


            git clone https://people.csail.mit.edu/hubert/git/pyaudio.git
          
To build PyAudio from source, you will also need to build PortAudio v19. See the INSTALLATION file in the PyAudio source bundle for build instructions.


Documentation & Examples
Browse the PyAudio API documentation. PyAudio roughly mirrors the PortAudio v19 API 2.0.

The PyAudio source distribution contains a set of demos. Here's a selection from that set:


"""PyAudio Example: Play a wave file."""

import 
wave
import 
sys

import 
pyaudio

CHUNK 
= 
1024

if 
len
(
sys
.
argv
) 
< 
2
:
    
print
(
f
'Plays a wave file. Usage: 
{
sys
.
argv
[
0
]
}
 filename.wav'
)
    
sys
.
exit
(
-
1
)

with 
wave
.
open
(
sys
.
argv
[
1
], 
'rb'
) 
as 
wf
:
    
# Instantiate PyAudio and initialize PortAudio system resources (1)
    
p 
= 
pyaudio
.
PyAudio
()

    
# Open stream (2)
    
stream 
= 
p
.
open
(
format
=
p
.
get_format_from_width
(
wf
.
getsampwidth
()),
                    
channels
=
wf
.
getnchannels
(),
                    
rate
=
wf
.
getframerate
(),
                    
output
=
True
)

    
# Play samples from the wave file (3)
    
while 
len
(
data 
:= 
wf
.
readframes
(
CHUNK
)):  
# Requires Python 3.8+ for :=
        
stream
.
write
(
data
)

    
# Close stream (4)
    
stream
.
close
()

    
# Release PortAudio system resources (5)
    
p
.
terminate
()

"""PyAudio Example: Record a few seconds of audio and save to a wave file."""

import 
wave
import 
sys

import 
pyaudio

CHUNK 
= 
1024
FORMAT 
= 
pyaudio
.
paInt16
CHANNELS 
= 
1 
if 
sys
.
platform 
== 
'darwin' 
else 
2
RATE 
= 
44100
RECORD_SECONDS 
= 
5

with 
wave
.
open
(
'output.wav'
, 
'wb'
) 
as 
wf
:
    
p 
= 
pyaudio
.
PyAudio
()
    
wf
.
setnchannels
(
CHANNELS
)
    
wf
.
setsampwidth
(
p
.
get_sample_size
(
FORMAT
))
    
wf
.
setframerate
(
RATE
)

    
stream 
= 
p
.
open
(
format
=
FORMAT
, 
channels
=
CHANNELS
, 
rate
=
RATE
, 
input
=
True
)

    
print
(
'Recording...'
)
    
for 
_ 
in 
range
(
0
, 
RATE 
// 
CHUNK 
* 
RECORD_SECONDS
):
        
wf
.
writeframes
(
stream
.
read
(
CHUNK
))
    
print
(
'Done'
)

    
stream
.
close
()
    
p
.
terminate
()

"""PyAudio Example: full-duplex wire between input and output."""

import 
sys

import 
pyaudio

RECORD_SECONDS 
= 
5
CHUNK 
= 
1024
RATE 
= 
44100

p 
= 
pyaudio
.
PyAudio
()
stream 
= 
p
.
open
(
format
=
p
.
get_format_from_width
(
2
),
                
channels
=
1 
if 
sys
.
platform 
== 
'darwin' 
else 
2
,
                
rate
=
RATE
,
                
input
=
True
,
                
output
=
True
,
                
frames_per_buffer
=
CHUNK
)

print
(
'* recording'
)
for 
i 
in 
range
(
0
, 
int
(
RATE 
/ 
CHUNK 
* 
RECORD_SECONDS
)):
    
stream
.
write
(
stream
.
read
(
CHUNK
))
print
(
'* done'
)

stream
.
close
()
p
.
terminate
()

"""PyAudio Example: Play a wave file (callback version)."""

import 
wave
import 
time
import 
sys

import 
pyaudio

if 
len
(
sys
.
argv
) 
< 
2
:
    
print
(
f
'Plays a wave file. Usage: 
{
sys
.
argv
[
0
]
}
 filename.wav'
)
    
sys
.
exit
(
-
1
)

with 
wave
.
open
(
sys
.
argv
[
1
], 
'rb'
) 
as 
wf
:
    
# Define callback for playback (1)
    
def 
callback
(
in_data
, 
frame_count
, 
time_info
, 
status
):
        
data 
= 
wf
.
readframes
(
frame_count
)
        
# If len(data) is less than requested frame_count, PyAudio automatically
        
# assumes the stream is finished, and the stream stops.
        
return 
(
data
, 
pyaudio
.
paContinue
)

    
# Instantiate PyAudio and initialize PortAudio system resources (2)
    
p 
= 
pyaudio
.
PyAudio
()

    
# Open stream using callback (3)
    
stream 
= 
p
.
open
(
format
=
p
.
get_format_from_width
(
wf
.
getsampwidth
()),
                    
channels
=
wf
.
getnchannels
(),
                    
rate
=
wf
.
getframerate
(),
                    
output
=
True
,
                    
stream_callback
=
callback
)

    
# Wait for stream to finish (4)
    
while 
stream
.
is_active
():
        
time
.
sleep
(
0.1
)

    
# Close the stream (5)
    
stream
.
close
()

    
# Release PortAudio system resources (6)
    
p
.
terminate
()

"""PyAudio Example: Audio wire between input and output. Callback version."""

import 
time
import 
sys

import 
pyaudio

DURATION 
= 
5  
# seconds

def 
callback
(
in_data
, 
frame_count
, 
time_info
, 
status
):
    
return 
(
in_data
, 
pyaudio
.
paContinue
)

p 
= 
pyaudio
.
PyAudio
()
stream 
= 
p
.
open
(
format
=
p
.
get_format_from_width
(
2
),
                
channels
=
1 
if 
sys
.
platform 
== 
'darwin' 
else 
2
,
                
rate
=
44100
,
                
input
=
True
,
                
output
=
True
,
                
stream_callback
=
callback
)

start 
= 
time
.
time
()
while 
stream
.
is_active
() 
and 
(
time
.
time
() 
- 
start
) 
< 
DURATION
:
    
time
.
sleep
(
0.1
)

stream
.
close
()
p
.
terminate
()

"""PyAudio Example: macOS-only: Play a wave file with channel maps."""

import 
wave
import 
sys

import 
pyaudio


CHUNK 
= 
1024

if 
len
(
sys
.
argv
) 
< 
2
:
    
print
(
f
'Plays a wave file. Usage: 
{
sys
.
argv
[
0
]
}
 filename.wav'
)
    
sys
.
exit
(
-
1
)

# standard L-R stereo
# channel_map = (0, 1)

# reverse: R-L stereo
# channel_map = (1, 0)

# no audio
# channel_map = (-1, -1)

# left channel audio --> left speaker; no right channel
# channel_map = (0, -1)

# right channel audio --> right speaker; no left channel
# channel_map = (-1, 1)

# left channel audio --> right speaker
# channel_map = (-1, 0)

# right channel audio --> left speaker
channel_map 
= 
(
1
, 
-
1
)
# etc...
try
:
    
stream_info 
= 
pyaudio
.
PaMacCoreStreamInfo
(
        
flags
=
pyaudio
.
PaMacCoreStreamInfo
.
paMacCorePlayNice
,
        
channel_map
=
channel_map
)
except 
AttributeError
:
    
print
(
        
'Could not find PaMacCoreStreamInfo. Ensure you are running on macOS.'
)
    
sys
.
exit
(
-
1
)

print
(
'Stream Info Flags:'
, 
stream_info
.
flags
)
print
(
'Stream Info Channel Map:'
, 
stream_info
.
channel_map
)

with 
wave
.
open
(
sys
.
argv
[
1
], 
'rb'
) 
as 
wf
:
    
p 
= 
pyaudio
.
PyAudio
()
    
stream 
= 
p
.
open
(
        
format
=
p
.
get_format_from_width
(
wf
.
getsampwidth
()),
        
channels
=
wf
.
getnchannels
(),
        
rate
=
wf
.
getframerate
(),
        
output
=
True
,
        
output_host_api_specific_stream_info
=
stream_info
)

    
# Play stream
    
while 
len
(
data 
:= 
wf
.
readframes
(
CHUNK
)):  
# Requires Python 3.8+ for :=
        
stream
.
write
(
data
)

    
stream
.
close
()
    
p
.
terminate
()

License
PyAudio is distributed under the MIT License:

Copyright (c) 2006 Hubert Pham

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


Acknowledgements
Many thanks to Andrew Baldwin, Alex ThreeD, Timothée Lecomte, Frank Samuelson, Matthieu Brucher, Chris Stawarz, Barry Walker, Bob Jamison, Danilo J. S. Bellini, Bastian Bechtold, Christoph Gohlke, Sebastian Audet, Jason Roehm, Tony Jacobson, Sami Liedes, Michael Graczyk, Blaise Potard, Matthias Schaff, Timothy Port, Sean Zimmermann, Jason Hihn, Eiichi Takamori, Matěj Cepl, Vasily Zakharov, Artur Janowiec, and Bhanu Victor DiCara for their much appreciated suggestions and patches—as well as to others who have written to say hello!

Special thanks to Felipe Sateler and Justin Mazzola Paluska for Debian/Ubuntu packaging help.

The development of PyAudio was funded in part by the Cambridge-MIT Institute and T-Party.


Contact
For help with PyAudio, your best bet for a timely response is to consult or post to StackOverflow.

Comments, suggestions, and patches welcomed. Send mail to my first name at mit.edu.


indexmodules |PyAudio 0.2.14 documentation » PyAudio Documentation
PyAudio Documentation
Contents

PyAudio Documentation

Introduction

Example: Blocking Mode Audio I/O

Example: Callback Mode Audio I/O

Overview

Details

Class PyAudio

Class PyAudio.Stream

Platform Specific

Indices and tables

Introduction
PyAudio provides Python bindings for PortAudio, the cross-platform audio I/O library. With PyAudio, you can easily use Python to play and record audio on a variety of platforms.

Example: Blocking Mode Audio I/O
"""PyAudio Example: Play a wave file."""

import wave
import sys

import pyaudio


CHUNK = 1024

if len(sys.argv) < 2:
    print(f'Plays a wave file. Usage: {sys.argv[0]} filename.wav')
    sys.exit(-1)

with wave.open(sys.argv[1], 'rb') as wf:
    # Instantiate PyAudio and initialize PortAudio system resources (1)
    p = pyaudio.PyAudio()

    # Open stream (2)
    stream = p.open(format=p.get_format_from_width(wf.getsampwidth()),
                    channels=wf.getnchannels(),
                    rate=wf.getframerate(),
                    output=True)

    # Play samples from the wave file (3)
    while len(data := wf.readframes(CHUNK)):  # Requires Python 3.8+ for :=
        stream.write(data)

    # Close stream (4)
    stream.close()

    # Release PortAudio system resources (5)
    p.terminate()
To use PyAudio, first instantiate PyAudio using pyaudio.PyAudio() (1), which acquires system resources for PortAudio.

To record or play audio, open a stream on the desired device with the desired audio parameters using pyaudio.PyAudio.open() (2). This sets up a pyaudio.PyAudio.Stream to play or record audio.

Play audio by writing audio data to the stream using pyaudio.PyAudio.Stream.write(), or read audio data from the stream using pyaudio.PyAudio.Stream.read(). (3)

Note that in “blocking mode”, each pyaudio.PyAudio.Stream.write() or pyaudio.PyAudio.Stream.read() blocks until all frames have been played/recorded. An alternative approach is “callback mode”, described below, in which PyAudio invokes a user-defined function to process recorded audio or generate output audio.

Use pyaudio.PyAudio.Stream.close() to close the stream. (4)

Finally, terminate the PortAudio session and release system resources using pyaudio.PyAudio.terminate(). (5)

Example: Callback Mode Audio I/O
"""PyAudio Example: Play a wave file (callback version)."""

import wave
import time
import sys

import pyaudio


if len(sys.argv) < 2:
    print(f'Plays a wave file. Usage: {sys.argv[0]} filename.wav')
    sys.exit(-1)

with wave.open(sys.argv[1], 'rb') as wf:
    # Define callback for playback (1)
    def callback(in_data, frame_count, time_info, status):
        data = wf.readframes(frame_count)
        # If len(data) is less than requested frame_count, PyAudio automatically
        # assumes the stream is finished, and the stream stops.
        return (data, pyaudio.paContinue)

    # Instantiate PyAudio and initialize PortAudio system resources (2)
    p = pyaudio.PyAudio()

    # Open stream using callback (3)
    stream = p.open(format=p.get_format_from_width(wf.getsampwidth()),
                    channels=wf.getnchannels(),
                    rate=wf.getframerate(),
                    output=True,
                    stream_callback=callback)

    # Wait for stream to finish (4)
    while stream.is_active():
        time.sleep(0.1)

    # Close the stream (5)
    stream.close()

    # Release PortAudio system resources (6)
    p.terminate()
In callback mode, PyAudio will call a user-defined callback function (1) whenever it needs new audio data to play and/or when new recorded audio data becomes available. PyAudio calls the callback function in a separate thread. The callback function must have the following signature callback(<input_data>, <frame_count>, <time_info>, <status_flag>). It must return a tuple containing frame_count frames of audio data to output (for output streams) and a flag signifying whether there are more expected frames to play or record. (For input-only streams, the audio data portion of the return value is ignored.)

The audio stream starts processing once the stream is opened (3), which will call the callback function repeatedly until that function returns pyaudio.paComplete or pyaudio.paAbort, or until either pyaudio.PyAudio.Stream.stop or pyaudio.PyAudio.Stream.close is called. Note that if the callback returns fewer frames than the frame_count argument (2), the stream automatically closes after those frames are played.

To keep the stream active, the main thread must remain alive, e.g., by sleeping (4). In the example above, once the entire wavefile is read, wf.readframes(frame_count) will eventually return fewer than the requested frames. The stream will stop, and the while loop (4) will end.

Overview
Classes
PyAudio, PyAudio.Stream

Host Specific Classes
PaMacCoreStreamInfo

Stream Conversion Convenience Functions
get_sample_size(), get_format_from_width()

PortAudio version
get_portaudio_version(), get_portaudio_version_text()

Portaudio Sample Formats
paFloat32, paInt32, paInt24, paInt16, paInt8, paUInt8, paCustomFormat

PortAudio Host APIs
paInDevelopment, paDirectSound, paMME, paASIO, paSoundManager, paCoreAudio, paOSS, paALSA, paAL, paBeOS, paWDMKS, paJACK, paWASAPI, paNoDevice

PortAudio Error Codes
paNoError, paNotInitialized, paUnanticipatedHostError, paInvalidChannelCount, paInvalidSampleRate, paInvalidDevice, paInvalidFlag, paSampleFormatNotSupported, paBadIODeviceCombination, paInsufficientMemory, paBufferTooBig, paBufferTooSmall, paNullCallback, paBadStreamPtr, paTimedOut, paInternalError, paDeviceUnavailable, paIncompatibleHostApiSpecificStreamInfo, paStreamIsStopped, paStreamIsNotStopped, paInputOverflowed, paOutputUnderflowed, paHostApiNotFound, paInvalidHostApi, paCanNotReadFromACallbackStream, paCanNotWriteToACallbackStream, paCanNotReadFromAnOutputOnlyStream, paCanNotWriteToAnInputOnlyStream, paIncompatibleStreamHostApi

PortAudio Callback Return Codes
paContinue, paComplete, paAbort

PortAudio Callback Flags
paInputUnderflow, paInputOverflow, paOutputUnderflow, paOutputOverflow, paPrimingOutput

Details
pyaudio.get_format_from_width(width, unsigned=True)
Returns a PortAudio format constant for the specified width.

Parameters:
width – The desired sample width in bytes (1, 2, 3, or 4)

unsigned – For 1 byte width, specifies signed or unsigned format.

Raises:
ValueError – when invalid width

Return type:
A PortAudio Sample Format constant

pyaudio.get_portaudio_version()
Returns portaudio version.

Return type:
int

pyaudio.get_portaudio_version_text()
Returns PortAudio version as a text string.

Return type:
string

pyaudio.get_sample_size(format)
Returns the size (in bytes) for the specified sample format.

Parameters:
format – A PortAudio Sample Format constant.

Raises:
ValueError – on invalid specified format.

Return type:
integer

pyaudio.paAL = 9
Open Audio Library

pyaudio.paALSA = 8
Advanced Linux Sound Architecture (Linux only)

pyaudio.paASIO = 3
Steinberg Audio Stream Input/Output

pyaudio.paAbort = 2
An error ocurred, stop playback/recording

pyaudio.paBeOS = 10
BeOS Sound System

pyaudio.paComplete = 1
This was the last block of audio data

pyaudio.paContinue = 0
There is more audio data to come

pyaudio.paCoreAudio = 5
CoreAudio (OSX only)

pyaudio.paCustomFormat = 65536
a custom data format

pyaudio.paDirectSound = 1
DirectSound (Windows only)

pyaudio.paFloat32 = 1
32 bit float

pyaudio.paInDevelopment = 0
Still in development

pyaudio.paInputOverflow = 2
Buffer overflow in input

pyaudio.paInputUnderflow = 1
Buffer underflow in input

pyaudio.paInt16 = 8
16 bit int

pyaudio.paInt24 = 4
24 bit int

pyaudio.paInt32 = 2
32 bit int

pyaudio.paInt8 = 16
8 bit int

pyaudio.paJACK = 12
JACK Audio Connection Kit

pyaudio.paMME = 2
Multimedia Extension (Windows only)

pyaudio.paNoDevice = -1
Not actually an audio device

pyaudio.paOSS = 7
Open Sound System (Linux only)

pyaudio.paOutputOverflow = 8
Buffer overflow in output

pyaudio.paOutputUnderflow = 4
Buffer underflow in output

pyaudio.paPrimingOutput = 16
Just priming, not playing yet

pyaudio.paSoundManager = 4
SoundManager (OSX only)

pyaudio.paUInt8 = 32
8 bit unsigned int

pyaudio.paWASAPI = 13
Windows Vista Audio stack architecture

pyaudio.paWDMKS = 11
Windows Driver Model (Windows only)

Class PyAudio
class pyaudio.PyAudio
Python interface to PortAudio.

Provides methods to:
initialize and terminate PortAudio

open and close streams

query and inspect the available PortAudio Host APIs

query and inspect the available PortAudio audio devices.

Stream Management
open(), close()

Host API
get_host_api_count(), get_default_host_api_info(), get_host_api_info_by_type(), get_host_api_info_by_index(), get_device_info_by_host_api_device_index()

Device API
get_device_count(), is_format_supported(), get_default_input_device_info(), get_default_output_device_info(), get_device_info_by_index()

Stream Format Conversion
get_sample_size(), get_format_from_width()

Details

__init__()
Initialize PortAudio.

__weakref__
list of weak references to the object (if defined)

close(stream)
Closes a stream. Use PyAudio.Stream.close() instead.

Parameters:
stream – An instance of the PyAudio.Stream object.

Raises:
ValueError – if stream does not exist.

get_default_host_api_info()
Returns a dictionary containing the default Host API parameters.

The keys of the dictionary mirror the data fields of PortAudio’s PaHostApiInfo structure.

Raises:
IOError – if no default input device is available

Return type:
dict

get_default_input_device_info()
Returns the default input device parameters as a dictionary.

The keys of the dictionary mirror the data fields of PortAudio’s PaDeviceInfo structure.

Raises:
IOError – No default input device available.

Return type:
dict

get_default_output_device_info()
Returns the default output device parameters as a dictionary.

The keys of the dictionary mirror the data fields of PortAudio’s PaDeviceInfo structure.

Raises:
IOError – No default output device available.

Return type:
dict

get_device_count()
Returns the number of PortAudio Host APIs.

Return type:
integer

get_device_info_by_host_api_device_index(host_api_index, host_api_device_index)
Returns a dictionary containing the Device parameters for a given Host API’s n’th device. The keys of the dictionary mirror the data fields of PortAudio’s PaDeviceInfo structure.

Parameters:
host_api_index – The Host API index number

host_api_device_index – The n’th device of the host API

Raises:
IOError – for invalid indices

Return type:
dict

get_device_info_by_index(device_index)
Returns the device parameters for device specified in device_index as a dictionary. The keys of the dictionary mirror the data fields of PortAudio’s PaDeviceInfo structure.

Parameters:
device_index – The device index

Raises:
IOError – Invalid device_index.

Return type:
dict

get_format_from_width(width, unsigned=True)
Returns a PortAudio format constant for the specified width.

Parameters:
width – The desired sample width in bytes (1, 2, 3, or 4)

unsigned – For 1 byte width, specifies signed or unsigned format.

Raises:
ValueError – for invalid width

Return type:
A PortAudio Sample Format constant.

get_host_api_count()
Returns the number of available PortAudio Host APIs.

Return type:
integer

get_host_api_info_by_index(host_api_index)
Returns a dictionary containing the Host API parameters for the host API specified by the host_api_index. The keys of the dictionary mirror the data fields of PortAudio’s PaHostApiInfo structure.

Parameters:
host_api_index – The host api index

Raises:
IOError – for invalid host_api_index

Return type:
dict

get_host_api_info_by_type(host_api_type)
Returns a dictionary containing the Host API parameters for the host API specified by the host_api_type. The keys of the dictionary mirror the data fields of PortAudio’s PaHostApiInfo structure.

Parameters:
host_api_type – The desired PortAudio Host API

Raises:
IOError – for invalid host_api_type

Return type:
dict

get_sample_size(format)
Returns the size (in bytes) for the specified sample format (a PortAudio Sample Format constant).

Parameters:
format – A PortAudio Sample Format constant.

Raises:
ValueError – Invalid specified format.

Return type:
integer

is_format_supported(rate, input_device=None, input_channels=None, input_format=None, output_device=None, output_channels=None, output_format=None)
Checks if specified device configuration is supported.

Returns True if the configuration is supported; raises ValueError otherwise.

Parameters:
rate – Specifies the desired rate (in Hz)

input_device – The input device index. Specify None (default) for half-duplex output-only streams.

input_channels – The desired number of input channels. Ignored if input_device is not specified (or None).

input_format – PortAudio sample format constant defined in this module

output_device – The output device index. Specify None (default) for half-duplex input-only streams.

output_channels – The desired number of output channels. Ignored if input_device is not specified (or None).

output_format – PortAudio Sample Format constant.

Return type:
bool

Raises:
ValueError – tuple containing (error string, PortAudio Error Code).

open(*args, **kwargs)
Opens a new stream.

See constructor for PyAudio.Stream.__init__() for parameter details.

Returns:
A new PyAudio.Stream

terminate()
Terminates PortAudio.

Attention:
Be sure to call this method for every instance of this object to release PortAudio resources.

Class PyAudio.Stream
class pyaudio.PyAudio.Stream(PA_manager, rate, channels, format, input=False, output=False, input_device_index=None, output_device_index=None, frames_per_buffer=0, start=True, input_host_api_specific_stream_info=None, output_host_api_specific_stream_info=None, stream_callback=None)
PortAudio Stream Wrapper. Use PyAudio.open() to instantiate.

Opening and Closing
__init__(), close()

Stream Info
get_input_latency(), get_output_latency(), get_time(), get_cpu_load()

Stream Management
start_stream(), stop_stream(), is_active(), is_stopped()

Input Output
write(), read(), get_read_available(), get_write_available()

__init__(PA_manager, rate, channels, format, input=False, output=False, input_device_index=None, output_device_index=None, frames_per_buffer=0, start=True, input_host_api_specific_stream_info=None, output_host_api_specific_stream_info=None, stream_callback=None)
Initialize an audio stream.

Do not call directly. Use PyAudio.open().

A stream can either be input, output, or both.

Parameters:
PA_manager – A reference to the managing PyAudio instance

rate – Sampling rate

channels – Number of channels

format – Sampling size and format. See PortAudio Sample Format.

input – Specifies whether this is an input stream. Defaults to False.

output – Specifies whether this is an output stream. Defaults to False.

input_device_index – Index of Input Device to use. Unspecified (or None) uses default device. Ignored if input is False.

output_device_index – Index of Output Device to use. Unspecified (or None) uses the default device. Ignored if output is False.

frames_per_buffer – Specifies the number of frames per buffer.

start – Start the stream running immediately. Defaults to True. In general, there is no reason to set this to False.

input_host_api_specific_stream_info –

Specifies a host API specific stream information data structure for input.

See PaMacCoreStreamInfo.

output_host_api_specific_stream_info –

Specifies a host API specific stream information data structure for output.

See PaMacCoreStreamInfo.

stream_callback –

Specifies a callback function for non-blocking (callback) operation. Default is None, which indicates blocking operation (i.e., PyAudio.Stream.read() and PyAudio.Stream.write()). To use non-blocking operation, specify a callback that conforms to the following signature:

callback(in_data,      # input data if input=True; else None
         frame_count,  # number of frames
         time_info,    # dictionary
         status_flags) # PaCallbackFlags
time_info is a dictionary with the following keys: input_buffer_adc_time, current_time, and output_buffer_dac_time; see the PortAudio documentation for their meanings. status_flags is one of PortAutio Callback Flag.

The callback must return a tuple:

(out_data, flag)
out_data is a byte array whose length should be the (frame_count * channels * bytes-per-channel) if output=True or None if output=False. flag must be either paContinue, paComplete or paAbort (one of PortAudio Callback Return Code). When output=True and out_data does not contain at least frame_count frames, paComplete is assumed for flag.

Note: stream_callback is called in a separate thread (from the main thread). Exceptions that occur in the stream_callback will:

print a traceback on standard error to aid debugging,

queue the exception to be thrown (at some point) in the main thread, and

return paAbort to PortAudio to stop the stream.

Note: Do not call PyAudio.Stream.read() or PyAudio.Stream.write() if using non-blocking operation.

See: PortAudio’s callback signature for additional details: http://portaudio.com/docs/v19-doxydocs/portaudio_8h.html#a8a60fb2a5ec9cbade3f54a9c978e2710

Raises:
ValueError – Neither input nor output are set True.

__weakref__
list of weak references to the object (if defined)

close()
Closes the stream.

get_cpu_load()
Return the CPU load. Always 0.0 when using the blocking API.

Return type:
float

get_input_latency()
Returns the input latency.

Return type:
float

get_output_latency()
Returns the output latency.

Return type:
float

get_read_available()
Return the number of frames that can be read without waiting.

Return type:
integer

get_time()
Returns stream time.

Return type:
float

get_write_available()
Return the number of frames that can be written without waiting.

Return type:
integer

is_active()¶
Returns whether the stream is active.

Return type:
bool

is_stopped()
Returns whether the stream is stopped.

Return type:
bool

read(num_frames, exception_on_overflow=True)
Read samples from the stream.

Do not call when using non-blocking mode.

Parameters:
num_frames – The number of frames to read.

exception_on_overflow – Specifies whether an IOError exception should be thrown (or silently ignored) on input buffer overflow. Defaults to True.

Raises:
IOError – if stream is not an input stream or if the read operation was unsuccessful.

Return type:
bytes

start_stream()
Starts the stream.

stop_stream()
Stops the stream.

write(frames, num_frames=None, exception_on_underflow=False)
Write samples to the stream for playback.

Do not call when using non-blocking mode.

Parameters:
frames – The frames of data.

num_frames – The number of frames to write. Defaults to None, in which this value will be automatically computed.

exception_on_underflow – Specifies whether an IOError exception should be thrown (or silently ignored) on buffer underflow. Defaults to False for improved performance, especially on slower platforms.

Raises:
IOError – if the stream is not an output stream or if the write operation was unsuccessful.

Return type:
None

Platform Specific
Class PaMacCoreStreamInfo
class pyaudio.PaMacCoreStreamInfo(flags=None, channel_map=None)
PortAudio Host API Specific Stream Info for macOS-specific settings.

To configure macOS-specific settings, instantiate this class and pass it as the argument in PyAudio.open() to parameters input_host_api_specific_stream_info or output_host_api_specific_stream_info. (See PyAudio.Stream.__init__().)

Note:
macOS-only.

PortAudio Mac Core Flags
paMacCoreChangeDeviceParameters, paMacCoreFailIfConversionRequired, paMacCoreConversionQualityMin, paMacCoreConversionQualityMedium, paMacCoreConversionQualityLow, paMacCoreConversionQualityHigh, paMacCoreConversionQualityMax, paMacCorePlayNice, paMacCorePro, paMacCoreMinimizeCPUButPlayNice, paMacCoreMinimizeCPU

flags
The flags specified to the constructor.

Type:
PortAudio Mac Core Flags

channel_map
The channel_map specified to the constructor

Type:
tuple or None if unspecified

__init__(flags=None, channel_map=None)
Initialize with macOS setting flags and channel_map.

See PortAudio documentation for more details on these parameters.

Parameters:
flags – PortAudio Mac Core Flags OR’ed together.

channel_map – An array describing the channel mapping. See PortAudio documentation for usage.

__weakref__
list of weak references to the object (if defined)

get_channel_map()
Returns the channel map set at instantiation. Deprecated.

Return type:
tuple or None

Deprecated since version 0.2.13: Use channel_map property.

get_flags()
Returns the flags set at instantiation. Deprecated.

Return type:
integer

Deprecated since version 0.2.13: Use flags property.

Indices and tables
Index

Search Page

indexmodules |PyAudio 0.2.14 documentation » PyAudio Documentation
© Copyright 2006, Hubert Pham. Created using Sphinx 7.2.6.